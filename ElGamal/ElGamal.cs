using System.Security.Cryptography;
using System.Text;
using System.Xml;

namespace ElGamal;

[Serializable]
public struct ElGamalParameters {
    public byte[] P;
    public byte[] G;
    public byte[] Y;
    [NonSerialized] public byte[] X;
}
public abstract class ElGamal : AsymmetricAlgorithm
{
    public abstract void ImportParameters(ElGamalParameters pParameters);

    public abstract ElGamalParameters ExportParameters(bool
        pIncludePrivateParams);
    public abstract byte[] EncryptData(byte[] pData);    
    public abstract byte[] DecryptData(byte[] pData);
    public abstract byte[] Sign(byte[] pHashcode);
    public abstract bool VerifySignature(byte[] pHashcode, byte[] pSignature);
    
     public override string ToXmlString(bool pIncludePrivate) {
        ElGamalParameters xParams = ExportParameters(pIncludePrivate);
        // create a new string builder
        StringBuilder xSb = new StringBuilder(  );
        // add the header
        xSb.Append("<ElGamalKeyValue>");
        // add the public elements from the parameters
        xSb.Append("<P>" + Convert.ToBase64String(xParams.P) + "</P>");
        xSb.Append("<G>" + Convert.ToBase64String(xParams.G) + "</G>");
        xSb.Append("<Y>" + Convert.ToBase64String(xParams.Y) + "</Y>");
        if (pIncludePrivate) {
            // we need to include X, which is the part of private key
            xSb.Append("<X>" + Convert.ToBase64String(xParams.X) + "</X>");
        }
        // add the final element
        xSb.Append("</ElGamalKeyValue>");
        return xSb.ToString(  );
    }

    public override void FromXmlString(String pString) {
        // create the params that we will use as the result
        ElGamalParameters xParams = new ElGamalParameters(  );
        // create a text reader using a string reader
        XmlTextReader xReader = 
            new XmlTextReader(new System.IO.StringReader(pString));
        
        // run through the elements in the xml string
        while (xReader.Read(  )) {
            // we are only interested in processing start nodes
            if (true || xReader.IsStartElement(  )) {
                switch (xReader.Name) {
                    case "P":
                        // set the value for P
                        xParams.P =
                            Convert.FromBase64String(xReader.ReadString(  ));
                        break;
                    case "G":
                        // set the value for G
                        xParams.G = 
                            Convert.FromBase64String(xReader.ReadString(  ));
                        break;
                    case "Y":
                        // set the value for Y
                        xParams.Y = 
                            Convert.FromBase64String(xReader.ReadString(  ));
                        break;
                    case "X":
                        // set the value for X (this would not be found in a 
                        // string that was generated by excluding the private
                        // elements.
                        xParams.X = 
                            Convert.FromBase64String(xReader.ReadString(  ));
                        break;
                }
            }
        }
        // Import the result
        ImportParameters(xParams);
    }
}
